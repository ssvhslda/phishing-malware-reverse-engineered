## Dictionary hopping

```mermaid
flowchart LR
	abc --> cba
	cba --> world
	bac --> acb
	acb --> hello
	aab --> cab
	cab --> space
```

Instead using function names, property names, static strings, numbers, or even basic operators - this method puts all of those values and functions into objects (dictionaries) and then points to those data types with random keys. This method commonly uses more than one hop, meaning a key will give you a value that leads to another key with another value. Obscuring things under multiple levels of key-value pair references makes automated deobfuscation tricky because it could just be a normal variable. 

For example:

```js
var dict = {
    abc: 'cba',
    acb: 'hello',
    bac: 'acb',
    cba: 'world',
    cab: ' ',
    aab: 'cab'
}
console.log(dict[dict['bac']] + dict[dict['aab']] + dict[dict['abc']])
```

```mermaid
flowchart LR
	abc --> cba
	cba --> world
	bac --> acb
	acb --> hello
	aab --> cab
	cab --> space
	world --> output[hello world]
	hello --> output[hello world]
	space --> output[hello world]
```

Often times filler functions are added for confusion. These functions may simply run a function that is passed as a parameter with parameters given:

```js
function (func, param) {
    return func(param)
}
```

or just add things together. Note this method could add strings together or numbers

```js
function (a, b) {
    return a + b
}
```

This seems silly on a small scale but with dozens of these functions all referencing each other the code becomes hard to parse through, especially with other forms of obfuscation at play.

Add this to our previous example:

```js
var dict = {
    abc: 'cba',
    acb: 'hello',
    bac: 'acb',
    cba: 'world',
    cab: ' ',
    ccb: 'cab',
    bba: function (a) {
        return dict[a]
    },
    bab: function (a, b) {
        return a(b)
    },
    abb: function (a, b) {
        return a + b
    },
    aab: 'bba',
    aba: 'bab',
    baa: 'abb'
}
// hello world
console.log(
    dict[(dict[dict['aab']]('baa'))](
        dict[(dict[dict['aab']]('baa'))](
        dict[dict[dict['aba']](dict['bba'], 'bac')],
        dict[dict[dict['aba']](dict[dict['aab']], 'aab')]('cab')),
        dict[dict[dict['aba']](dict['bba'], 'abc')]
    )
)
```

```mermaid
flowchart LR
	abc --> cba
	cba --> world
	bac --> acb
	acb --> hello
	ccb --> cab
	cab --> space
	aab --> bba
	aba --> bab
	baa --> abb
	bba --> abc
	bba --> abc
	bba --> cba
	bba --> bac
	bba --> acb
	bba --> cab
	bba --> aab
	bba --> aba
	bba --> baa
	bba --> bba
	bab --> bba
	bab --> abb
	abb --> bab
	aba --> bab
	baa --> bab
	space --> abb
	hello --> abb
	world --> abb
	abb --> output[hello world]
```

This dictionary hopping can become very complex very quickly, utilizing multiple dictionaries to hop between and various interconnected properties and functions. Add obfuscation of the original properties of the dictionary and now you have a very tricky puzzle.


## While switch sequencing

A string containing a sequence of numbers and delimited by a symbol of some kind (in this case | ) is iterated through using a while loop with a switch statement that will execute the different cases in the order of the sequence in the string.

For example:

```js
var counter = 0, sequence = '4|0|3|1|2'.split("|")
while (true) {
    // pass the current step to take and then increment the counter
    switch (sequence[counter++]) {
        case "0":
            console.log('I run second')
            // use the continue statement to skip the break statement and start the next step
            continue
        case "1":
            console.log('I run second to last')
            // use the continue statement to skip the break statement and start the next step
            continue
        case "2":
            console.log('I run last')
            // use the continue statement to skip the break statement and start the next step
            continue
        case "3":
            console.log('I run third')
            // use the continue statement to skip the break statement and start the next step
            continue
        case "4":
            console.log('I run first')
            // use the continue statement to skip the break statement and start the next step
            continue
    }
    // if none of the cases are met (then the sequence is complete)
    // and this break statement will stop the while loop
    break
}
```

```mermaid
sequenceDiagram
	while ->> switch: start sequence
	switch ->> four: sequence step is 4
	four ->> while: continue loop
	while ->> switch: check next step
	switch ->> zero: sequence step is 0
	zero ->> while: continue loop
	while ->> switch: check next step
	switch ->> three: sequence step is 3
	three ->> while: continue loop
	while ->> switch: check next step
	switch ->> one: sequence step is 1
	one ->> while: continue loop
	while ->> switch: check next step
	switch ->> two: sequence step is 2
	two ->> while: continue loop
	while ->> switch: check next step
	switch ->> while: no more steps
	while ->> breakout: break while loop

```

## Token array shuffling

When you have strings that you use that you really don't want people or other programs knowing you use or how you use them you can play the classic game of cups for misdirection. This method takes sensitive data and adds boring but useful data as well as seemingly random strings that are actually parsed into numbers for solving an equation to reverse the shuffled array into the correct sequence.

The method looks something like this:

```js
(function () {
  while (true) {
    try {
      var _0x5ac255 =
        (parseInt(getItem(177)) / 1) * (parseInt(getItem(148)) / 2) +
        parseInt(getItem(216)) / 3 +
        -parseInt(getItem(180)) / 4 +
        -parseInt(getItem(154)) / 5 +
        -parseInt(getItem(117)) / 6 +
        (-parseInt(getItem(146)) / 7) * (-parseInt(getItem(141)) / 8) +
        (-parseInt(getItem(118)) / 9) * (-parseInt(getItem(208)) / 10);
      if (_0x5ac255 === 497928) break;
      else arr.push(arr.shift());
    } catch (_0xc353f9) {
      arr.push(arr.shift());
    }
  }
})()
```
It's a while loop that won't stop running until the math adds up to a specific number. That number, thanks to the equation set up, will only be reached when the array items are aligned in the right sequence and each array index referenced returns a number. The clever use of parseInt allows converting strings into numbers that don't look like they would be.

`"prototype","3908622tRbgmZ","144kNgXjw","getElementsByTagName","toLowerCase","ntXkS","RAVJP","push"`

This array contains 3 types of tokens:

1. Numbers followed by random useless letters: 3908622tRbgmZ, 144kNgXjw
1. Obvious properties and functions: prototype, getElementsByTagName, toLowerCase, push
1. Random looking strings that are actually used for dictionary hopping: ntXkS, RAVJP

When something like '3908622tRbgmZ' is pased into parseInt() you actually get back 3908622.
This method is used to obfuscate the nubmers that are actually used for the equation.
The getItem function subtracts a certain number from the number given to get the actual index of the array that will be used. Originally this type of method is obfuscated to look like so:

```js
function _0x4e78(_0x421f04, _0x24c9b3) {
  var _0x4ecbb3 = _0x1bc6();
  return (
    (_0x4e78 = function (_0x3d993b, _0x5f27a4) {
      _0x3d993b = _0x3d993b - 116;
      var _0xefcbf6 = _0x4ecbb3[_0x3d993b];
      return _0xefcbf6;
    }),
    _0x4e78(_0x421f04, _0x24c9b3)
  );
}
```

But all it is doing is this:

```js
function getItem(index) {
    return arr[index - 116]
}
```

The script gets the items in the array and runs the equation to see if it equals the desired number. Until it does, it will continue to push the first array item to the back: `arr.push(arr.shift())`

It is a clever method to re-order an array because it is a pain to decypher in your head or on paper, it's not worth it at all. Instead you can simply extract the array and the two functions mentioned and run them in an isolated console to get the correct sequence and save that for decoding the rest of the code.
