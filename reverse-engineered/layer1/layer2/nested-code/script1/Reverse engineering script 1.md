Extracted script 1 in nested html

```js
function _0x16cf(_0x537735, _0x41dec8) { var _0x1cd84e = _0x3f84(); return _0x16cf = function (_0x3ea00a, _0x2f43f5) { _0x3ea00a = _0x3ea00a - (-0x13c9 * 0x1 + -0x3 * -0x347 + 0x39e * 0x3); var _0x462044 = _0x1cd84e[_0x3ea00a]; return _0x462044; }, _0x16cf(_0x537735, _0x41dec8); } var _0x2407be = _0x16cf, _0x57439f = _0x16cf; (function (_0x210bba, _0x5713ef) { var _0x2aab6a = _0x16cf, _0x56b590 = _0x16cf, _0x1ffc6a = _0x210bba(); while (!![]) { try { var _0x5ed7ef = -parseInt(_0x2aab6a(0xe8)) / (-0xd * 0x9e + -0x864 + 0x106b) + parseInt(_0x2aab6a(0xea)) / (0x3 * -0x2af + -0x3b4 + -0x1 * -0xbc3) + -parseInt(_0x56b590(0xef)) / (0x3 * -0x4b3 + 0x1afb * 0x1 + -0xcdf) * (parseInt(_0x56b590(0xf5)) / (0x9 * -0x187 + -0x12e + 0xef1)) + -parseInt(_0x2aab6a(0xed)) / (0x26ba * 0x1 + 0xf1c * 0x2 + 0x5 * -0xdc9) + parseInt(_0x2aab6a(0xf1)) / (0x1d * -0x124 + -0xb * -0x345 + -0x1 * 0x2dd) * (parseInt(_0x2aab6a(0xe6)) / (-0x3 * 0x4e9 + 0x1ec1 + -0x3 * 0x555)) + -parseInt(_0x56b590(0xf3)) / (-0x1ad2 + 0x1 * 0x2125 + 0x9 * -0xb3) * (parseInt(_0x56b590(0xe7)) / (-0x9 * -0x26 + 0x9 * 0xbb + 0x120 * -0x7)) + parseInt(_0x56b590(0xec)) / (-0x188 * 0x6 + 0x1309 + -0x9cf); if (_0x5ed7ef === _0x5713ef) break; else _0x1ffc6a['push'](_0x1ffc6a['shift']()); } catch (_0x651dc8) { _0x1ffc6a['push'](_0x1ffc6a['shift']()); } } }(_0x3f84, -0x181ff * 0x5 + -0x398 * 0x216 + -0x3 * -0x6bdb2), window['ok'] = '', window[_0x2407be(0xe9)] = '', window[_0x57439f(0xf4)] = FG9952, window[_0x2407be(0xf2)] = HY8740); function isBase64(_0x30f788) { var _0x42e581 = _0x57439f, _0x30b4c5 = _0x57439f, _0x208cb9 = {}; _0x208cb9[_0x42e581(0xf0)] = function (_0x291652, _0x4bc1c6) { return _0x291652 == _0x4bc1c6; }; var _0x3f0cdf = _0x208cb9; return _0x3f0cdf[_0x42e581(0xf0)](_0x30f788[_0x30b4c5(0xeb)] % (-0xb12 + -0x351 + 0xe67), -0x1 * 0xdf6 + -0x2 * -0x7d4 + -0x7 * 0x3e) && /^[A-Za-z0-9+/]+[=]{0,2}$/[_0x30b4c5(0xf6)](_0x30f788); } isBase64(BH8710) ? window[_0x57439f(0xee)] = atob(BH8710) : window[_0x2407be(0xee)] = BH8710; function _0x3f84() { var _0x59ba46 = ['74706uhIMzb', 'mail', '32ZnmeCY', 'token', '24pWUbVW', 'test', '112cpUxDh', '745947AIcuKD', '529796hUvzBk', 'incr', '1041258CCcAHf', 'length', '6658530ppScsV', '651565BDQDQi', 'file', '27039SckinC', 'COMVb']; _0x3f84 = function () { return _0x59ba46; }; return _0x3f84(); }
```

used Used https://deobfuscate.io/

```js

function _0x16cf(_0x537735, _0x41dec8) {
  var _0x1cd84e = _0x3f84();
  return _0x16cf = function (_0x3ea00a, _0x2f43f5) {
    _0x3ea00a = _0x3ea00a - 230;
    var _0x462044 = _0x1cd84e[_0x3ea00a];
    return _0x462044;
  }, _0x16cf(_0x537735, _0x41dec8);
}
var _0x2407be = _0x16cf, _0x57439f = _0x16cf;
(function (_0x210bba, _0x5713ef) {
  var _0x2aab6a = _0x16cf, _0x56b590 = _0x16cf, _0x1ffc6a = _0x210bba();
  while (true) {
    try {
      var _0x5ed7ef = -parseInt(_0x2aab6a(232)) / 1 + parseInt(_0x2aab6a(234)) / 2 + -parseInt(_0x56b590(239)) / 3 * (parseInt(_0x56b590(245)) / 4) + -parseInt(_0x2aab6a(237)) / 5 + parseInt(_0x2aab6a(241)) / 6 * (parseInt(_0x2aab6a(230)) / 7) + -parseInt(_0x56b590(243)) / 8 * (parseInt(_0x56b590(231)) / 9) + parseInt(_0x56b590(236)) / 10;
      if (_0x5ed7ef === _0x5713ef) break; else _0x1ffc6a.push(_0x1ffc6a.shift());
    } catch (_0x651dc8) {
      _0x1ffc6a.push(_0x1ffc6a.shift());
    }
  }
}(_0x3f84, 339979), window.ok = "", window[_0x2407be(233)] = "", window[_0x57439f(244)] = FG9952, window[_0x2407be(242)] = HY8740);
function isBase64(_0x30f788) {
  var _0x42e581 = _0x57439f, _0x30b4c5 = _0x57439f, _0x208cb9 = {};
  _0x208cb9[_0x42e581(240)] = function (_0x291652, _0x4bc1c6) {
    return _0x291652 == _0x4bc1c6;
  };
  var _0x3f0cdf = _0x208cb9;
  return _0x3f0cdf[_0x42e581(240)](_0x30f788[_0x30b4c5(235)] % 4, 0) && /^[A-Za-z0-9+/]+[=]{0,2}$/[_0x30b4c5(246)](_0x30f788);
}
isBase64(BH8710) ? window[_0x57439f(238)] = atob(BH8710) : window[_0x2407be(238)] = BH8710;
function _0x3f84() {
  var _0x59ba46 = ["74706uhIMzb", "mail", "32ZnmeCY", "token", "24pWUbVW", "test", "112cpUxDh", "745947AIcuKD", "529796hUvzBk", "incr", "1041258CCcAHf", "length", "6658530ppScsV", "651565BDQDQi", "file", "27039SckinC", "COMVb"];
  _0x3f84 = function () {
    return _0x59ba46;
  };
  return _0x3f84();
}
```

Manually deobfuscated the rest

```js

/**
This whole script only does the following:
window.ok = ""
window.incr = ""
window.token = "ZlGZnmTtp7wJI8SoFVdzu2NvF"
window.mail = "chuck@hslda.org"
window.file = "https://datplast.com/images/V1.3.4.php"
 */


var tokenArray = ["74706uhIMzb", "mail", "32ZnmeCY", "token", "24pWUbVW", "test", "112cpUxDh", 
  "745947AIcuKD", "529796hUvzBk", "incr", "1041258CCcAHf", "length", "6658530ppScsV", 
  "651565BDQDQi", "file", "27039SckinC", "COMVb"]

function getToken(index) {
  return tokenArray[index]
}

// shuffles the tokenArray until it becomes:
// ["112cpUxDh","745947AIcuKD","529796hUvzBk","incr","1041258CCcAHf","length","6658530ppScsV","651565BDQDQi","file","27039SckinC","COMVb","74706uhIMzb","mail","32ZnmeCY","token","24pWUbVW","test"]
//
// the method uses parseInt which ignores the letters at the end of the strings that start with numbers and converts the numbers into a number data type
// the resulting numbers are then added, subtracted, multiplied and divided into the final number that once the array is in the desired sequence finally equals 339979 and the algorithm stops
// when the try catch is used for when words get passed into parseInt and NaN is attempted to be divided by a number and the evaluation breaks
// the evaluation breaking causes the whole array to shift once, pushing the first item to the back (which happens either way until the loop is finished)
(function () {
  while (true) {
    try {
      var n = -parseInt(getToken(2)) + 
        parseInt(getToken(4)) / 2 + 
        -parseInt(getToken(9)) / 3 * 
        (parseInt(getToken(15)) / 4) + 
        -parseInt(getToken(7)) / 5 + 
        parseInt(getToken(11)) / 6 * 
        (parseInt(getToken(0)) / 7) + 
        -parseInt(getToken(13)) / 8 * 
        (parseInt(getToken(1)) / 9) + 
        parseInt(getToken(6)) / 10;
      if (n === 339979) break; else tokenArray.push(tokenArray.shift());
    } catch (e) {
      tokenArray.push(tokenArray.shift());
    }
  }
})()


function isBase64(input) {
  // checks if the length of the input matches that of a base64 encoded string and the input is alphanumeric with the exception of = symbols
  return (input[getToken(5)] % 4 == 0) && /^[A-Za-z0-9+/]+[=]{0,2}$/[getToken(16)](input);
  // this method will really only work against urls being base64 encoded. It's a horrible and broken method for testing pretty much any other string
}

window.ok = ""
window[getToken(3)] = ""
window[getToken(14)] = FG9952 // ZlGZnmTtp7wJI8SoFVdzu2NvF
window[getToken(12)] = HY8740 // user's email address

// sets window.file to the global variable BH8710 (in this case https://datplast.com/images/V1.3.4.php) which is set outside of this script
isBase64(BH8710) ? window[getToken(8)] = atob(BH8710) : window[getToken(8)] = BH8710;
// this line checks to see if the URL from the global variable is base64 and decodes it if it is so
// this means that the script was built to support multiple modes and the more obfuscated method was not used
// which means that either original creator of this script is not the person who launched this attack or he has used this multiple times and strangly chose not to use the slightly less obfuscated method

```


